<!DOCTYPE html>
<html>
 <!-- Simulation of the operation of an automatic firefighting branch, e.g. TFT -->
 <!-- Attempt to use a simplified fluid flow model to adjust pressures/flow rates throughout a section of hose, valves and other infrastructure -->
 <!-- Created by Tristan Miller, May 2018 -->
 <!-- Download and then open in your browser. -->
<head>
<meta charset="utf-8">
<title>Automatic Branch Simulation</title>
<style>

//this CSS is terrible and I feel bad about it
canvas {
    border: 0px #CCC solid;
}

input[type="checkbox"]
{
  /* Double-sized Checkboxes */
  -ms-transform: scale(2); /* IE */
  -moz-transform: scale(2); /* FF */
  -webkit-transform: scale(2); /* Safari and Chrome */
  -o-transform: scale(2); /* Opera */
  padding: 10px;
}

#controls
{
  font-size: 110%;
  display: inline;
  padding:5px;
  padding-top: 0px;
}

label
{
 padding: 15px;
 padding-right: 2px;
}

div, button
{
 margin: 5px;
 margin-left:10px;
}

h2
{
 padding:0px;
 margin:0px;
}


</style>
</head>
<body>
<h1 id="theTitle">AutoBranch</h1>
<h2 id="status">0 | 0</h2>

<canvas id="canvas0" height="1024" width="1024" onclick="requestAnimationFrame(drawWorld)">This text is displayed if your browser don't support HTML5 Canvas!</canvas>

<script>

	var title = document.querySelector("#theTitle");
	var canvas0 = document.querySelector("#canvas0");
	var ctx0 = canvas0.getContext("2d");

	var width = canvas0.width; //main dimensions of the 'world' - canvas0 is the 'base layer' of the animation
	var height = canvas0.height;
	
	//create canvases that never appear onscreen or in the DOM but are used for layered rendering
	var canvas1 = document.createElement("canvas");
	canvas1.width = width;
	canvas1.height = height;
	var ctx1 = canvas1.getContext("2d");

	var canvas2 = document.createElement("canvas");
	canvas2.width = width;
	canvas2.height = height;
	var ctx2 = canvas2.getContext("2d");

	var canvas3 = document.createElement("canvas");
	canvas3.width = width;
	canvas3.height = height;
	var ctx3 = canvas3.getContext("2d");
	
	
//OBJECTS NEEDED
//Pipe element
/* 	fluid velocity
	fluid pressure
	fluid density
	mass of fluid in that section
	fluid resistance (function of fluid velocity)
	pressure drop across element (function of fluid velocity and fluid resistance)
	connections to other elements
	flow in
	flow out
*/

//Pipe 'network'
/*	Ordered list of pipe elements to imply connections betweeen elements
	This connectivity will hopefully end up being embedded in the pipe elements themselves -
	leaving this as a means of grouping elements that are in important sub-sections of the pipe network

*/
var elementLength = 100; //mm

var Pipe = function(diam, length, posX, angle) {
	this.diam = diam; 		//mm
	this.length = length; 	//mm
	this.posX = posX;
	this.angle = angle; //rotation ccw in radians
	
	var N = Math.round(length/elementLength);
	
	for (var i = 0; i < N; i++){
		var X;
		if(i == 0){X = 100;} else {X = this.elements[i - 1].posX + this.elements[i - 1].size + 0}
		var p = new PipeElement(this.diam, elementLength, X, height/2); //create a pipe's worth of elements
		p.pressure = pAtmo;
		this.elements.push(p);
	}
		
	for (var i = 0; i < N - 1; i++){
		var f = new Interface(this.elements[i], this.elements[i + 1]); //create interfaces joining each neighbouring element
		f.buildVelos();
		this.interfaces.push(f);
	}
	
	
	return this;
	
	
};

Pipe.prototype = {
	diam: 64, //mm
	length: 100, //mm
	posX: 0,
	angle: 0,
	elements: [],
	interfaces: [],
	label: "",
	
	calculateMassFlows: function(time_scale){
		for(var i = 0; i < this.elements.length; i++){  //reset mass flows to zero for this round of calculations
			this.elements[i].massFlow = 0;
		}
		for(var i = 0; i < this.interfaces.length; i++){ //calculate mass flows across each interface
			this.interfaces[i].calculateInterfaceMassFlows(time_scale);
		}
		for(var i = 0; i < this.elements.length; i++){  //update the mass of each pipe element
			this.elements[i].update();
		}
	},
	
	render: function(ctx){
		for(var i = 0; i < this.elements.length; i++){
			this.elements[i].render(ctx);
		}
	}
	
	
};

var Interface = function(elm1, elm2){
	this.elements = [elm1, elm2];
	this.velos = [];
	
}

Interface.prototype = {
	buildVelos: function(){ //build an NxN matrix to contain speeds across each pair of elements
		for(var i = 0; i < this.elements.length; i++){
			var sub = [];
			for(var j = 0; j < this.elements.length; j++){
				sub.push(0);
			}
			this.velos.push(sub);
		}	
	},


	calculateInterfaceMassFlows: function(time_scale){
		if(this.elements.length > 0){
			for(var i = 0; i < this.elements.length - 1; i++){
				for(var j = i + 1; j < this.elements.length; j++){
					var A = this.elements[i];
					var B = this.elements[j];
					var workingArea = Math.min(A.area,B.area)/1e6;  //find size of interface between pipe elements, then convert to m^2
					var F = (A.pressure - B.pressure)*workingArea;  //find net force in direction of B, Newtons
					var aA = 1000*(F/B.mass); //resultant acceleration of fluid in ms^-2
					var aB = 1000*(F/B.mass); //resultant acceleration of fluid in ms^-2
					
					aA = aA/time_scale;
					aB = aB/time_scale; //speed gain over time interval

					this.velos[i][j] += aA;
					this.velos[j][i] += aB; //new speed after accn over time interval, ms^-1

					var veloAtoB = this.velos[i][j];
					var veloBfromA = this.velos[j][i];
					
					A.massFlow -= (veloAtoB/time_scale)*(A.area/1000)*A.density;  //g of mass flow during time interval
					B.massFlow += (veloBfromA/time_scale)*(B.area/1000)*B.density;
				}
			}
		}
	}
}

var PipeElement = function(diam, length, posX, posY) {
    this.diam = diam;
	this.length = length; //mm
	this.posX = posX;
	this.posY = posY;
	
	this.area = (Math.PI*diam*diam*0.25);
	this.volume = this.area*this.length; //mm^3
	this.mass = this.volume*this.density/1000; //cross-sectional area * length * density in g/mm^3
	this.size = this.length;

    return this;
};


PipeElement.prototype = {
    diam: 64, //mm
	length: 1, //mm
	area: 1, //mm^2
	volume: 1, //cm^3
	mass: 1, //g
	pressure: 0, //gauge pressure, Pa
	density: 1, //g/cm^3
	massFlow: 0, //g, positive is IN
	k: 0, //friction coefficient;
	
	//RENDERING VARIABLES
	posX: 0,
	posY: 0,
	label: "",
	colour: "rgba(0, 0, 0, 1)",
	size: 20,  //size for rendering will depend on how many elements there are, and aesthetic considerations!


	changeDiam: function(newDiam){
		this.diam = newDiam;
		this.area = (Math.PI*this.diam*this.diam*0.25);
		this.volume = this.area*this.length; //mm^3
		this.mass = this.volume*this.density/1000;
		//this.density = 1000*this.mass/this.volume //cross-sectional area * length * density in g/mm^3;
	},
	
	
	densityFromPressure: function() {
		
		this.density = rho/(1 - (this.pressure - pAtmo)/K);
		this.mass = this.density*this.volume/1000;
	},

	
	update: function() {
		this.mass = this.mass + this.massFlow;
		var oldDensity = this.density;
		this.density = this.mass/(this.volume/1000);
		var oldPressure = this.pressure;
		this.pressure = K*(1 - (oldDensity/this.density)) + oldPressure;
		this.colour = "hsla(" + 200*(this.pressure - 100000)/900000 +", 100%, 50%, 1)" //pressure range between 2550000 and 0

	},

	
	
	render: function(ctx) {
        ctx.fillStyle= this.colour;
		ctx.strokeStyle = "rgba(255,255,255,0.4)";
		ctx.lineWidth = 1;
		ctx.fillStyle= this.colour;
		ctx.beginPath();
		ctx.save();
		ctx.translate(this.posX - 0.5*this.size, this.posY - 0.5*this.diam);
		ctx.rect(0,0, this.size, this.diam);
		ctx.fill();
		ctx.stroke();
		ctx.restore();
		ctx.font="9px Arial";
		ctx.fillText("p: " + Math.round(this.pressure/1000) + "kPa", this.posX - 0.5*this.size, this.posY - 100);
		ctx.fillText("mass: " + Math.round(this.mass)+ "g", this.posX - 0.5*this.size, this.posY - 80);
		ctx.fillText("q: " + Math.round(60*this.massFlow*timescale*physicsSteps)+ "L/m", this.posX - 0.5*this.size, this.posY - 60);


	}
	
};

var rho = 1 // density of fluid, g/cm^3
var K = 2e9; //  bulk modulus of fluid, Pa
var timescale = 60000; //how many frames are equivalent to 1 second?
var physicsSteps = 1000; //how much to subdivide each frame for finer (more accurate?) calculations
//consider also having within this a physics step time - do multiple (small) updates in a single frame
//to avoid overshoots
var pAtmo = 1e5; //atmospheric pressure, Pa
var POW = 100000; //watts of pump power

var thisPipe = new Pipe(64, 800, 0, 0);
thisPipe.elements[0].pressure = 1000000;

	   
function drawWorld(){   ///main animation loop
	ctx0.fillStyle = "rgba(100,0,100,1)";
	ctx0.fillRect(0,0,width,height);
	for(var j = 0; j < physicsSteps; j++){
		thisPipe.calculateMassFlows(timescale*physicsSteps);
	}
	ctx1.clearRect(0,0,width,height);
	
	thisPipe.render(ctx1);
	

	/*
	var nozDiff = thisPipe[N - 2 - thisPCUElements].pressure - thisPipe[N-1].pressure;
	var nozDiam = thisPipe[N-2].diam;
	for(var i=0; i < thisPCUElements; i++){
		if(nozDiff > 800000){
			if(nozDiff < 750000){
				thisPCU[i].changeDiam(nozDiam*1.0001);
			} else {
				thisPCU[i].changeDiam(nozDiam*1.001);
			}
		}
		if(nozDiff < 600000){
			if(nozDiff > 650000){
				thisPCU[i].changeDiam(nozDiam*0.9999);
			} else {
				thisPCU[i].changeDiam(nozDiam*0.999);
			}
		}
		
	}
	*/
	
	
	ctx0.drawImage(canvas1,0,0);

	requestAnimationFrame(drawWorld);
}
console.log("All good!");
drawWorld();


/* deprecated - to be handled by Interfaces
function calculateElementMassFlows(peL,peR){
	var pL = peL.pressure;
	var pR = peR.pressure;
	var workingArea = Math.min(peL.area,peR.area)/1e6;  //find size of interface between pipe elements, then convert to m^2
	var FL = pL*workingArea - peL.k*peL.veloR*peL.veloR; // F is in Newtons
	var FR = pR*workingArea - peR.k*peR.veloL*peR.veloL; //F is in Newtons
	var F = FL - FR; //meaning that a net force to the right will be positive
	var aL = (F/peL.mass); //resultant acceleration of fluid in ms^-2
	var aR = (F/peR.mass); //resultant acceleration of fluid in ms^-2
	aL = aL/(timescale*physicsSteps);
	aR = aR/(timescale*physicsSteps);

	peL.veloR = (1 - 100/(timescale*physicsSteps))*peL.veloR + aR;
	peR.veloL = (1 - 100/(timescale*physicsSteps))*peR.veloL + aL;
	peL.massFlowR = (peL.veloR)*(peL.area/1000)*peL.density;
	peR.massFlowL = (peR.veloL)*(peR.area/1000)*peR.density;
	var massFlow = Math.min(Math.abs(peL.massFlowR, peR.massFlowL));
	peL.massFlowR = Math.sign(peL.massFlowR)*massFlow;
	peR.massFlowL = peL.massFlowR; //all about continuity of mass over the boundary between the elements. This chooses the smallest mass flow of the two to be applied to both.
	
}

*/


</script>
</body>
