<!DOCTYPE html>
<html>
 <!-- Simulation of the operation of an automatic firefighting branch, e.g. TFT -->
 <!-- Attempt to use a simplified fluid flow model to adjust pressures/flow rates throughout a section of hose, valves and other infrastructure -->
 <!-- Created by Tristan Miller, May 2018 -->
 <!-- Download and then open in your browser. -->
<head>
<meta charset="utf-8">
<title>Automatic Branch Simulation</title>
<style>

//this CSS is terrible and I feel bad about it
canvas {
    border: 0px #CCC solid;
}

input[type="checkbox"]
{
  /* Double-sized Checkboxes */
  -ms-transform: scale(2); /* IE */
  -moz-transform: scale(2); /* FF */
  -webkit-transform: scale(2); /* Safari and Chrome */
  -o-transform: scale(2); /* Opera */
  padding: 10px;
}

#controls
{
  font-size: 110%;
  display: inline;
  padding:5px;
  padding-top: 0px;
}

label
{
 padding: 15px;
 padding-right: 2px;
}

div, button
{
 margin: 5px;
 margin-left:10px;
}

h2
{
 padding:0px;
 margin:0px;
}


</style>
</head>
<body>
<h1 id="theTitle">AutoBranch</h1>
<h3 id="status">0 | 0</h2>

<canvas id="canvas0" height="800" width="1024" onclick="requestAnimationFrame(drawWorld)">This text is displayed if your browser don't support HTML5 Canvas!</canvas>

<div id="controls">
	<div id = "throttles">
	</div>
	<div id = "valves">
	</div>
</div>
<script>

	var title = document.querySelector("#theTitle");
	var canvas0 = document.querySelector("#canvas0");
	var ctx0 = canvas0.getContext("2d");

	var width = canvas0.width; //main dimensions of the 'world' - canvas0 is the 'base layer' of the animation
	var height = canvas0.height;
	
	//create canvases that never appear onscreen or in the DOM but are used for layered rendering
	var canvas1 = document.createElement("canvas");
	canvas1.width = width;
	canvas1.height = height;
	var ctx1 = canvas1.getContext("2d");

	var canvas2 = document.createElement("canvas");
	canvas2.width = width;
	canvas2.height = height;
	var ctx2 = canvas2.getContext("2d");

	var canvas3 = document.createElement("canvas");
	canvas3.width = width;
	canvas3.height = height;
	var ctx3 = canvas3.getContext("2d");
	
	var controlPanel = document.getElementById("controls");
	controlPanel.addEventListener("input", doThing, false);
	
	var today = new Date();
	document.getElementById("status").innerHTML = today;
	
	function doThing(e){
		if (e.target !== e.currentTarget) {
			var inputSN = e.target.dataset.connectedto;
			var inputObject = Controls[inputSN];
			inputObject.applySliderValue(e.target.value);
		}
		e.stopPropagation();
	}



var Pipe = function(diam, length, posX, posY, angle) {
	this.diam = diam; 		//mm
	this.length = length; 	//mm
	this.posX = posX;
	this.posY = posY; //starting position of pipe
	this.angle = angle; //rotation ccw in radians
	this.elements = [];
	this.interfaces = [];
	
	var N = Math.round(length/(elementLength));
	
	for (var i = 0; i < N; i++){
		var X;
		if(i == 0){X = this.posX+ 100;} else {X = this.elements[i - 1].posX + this.elements[i - 1].size}
		var p = new PipeElement(this.diam, elementLength, X, this.posY); //create a pipe's worth of elements
		p.pressure = pAtmo;
		this.elements.push(p);
	}
		
	for (var i = 0; i < N - 1; i++){
		var f = new Interface([this.elements[i], this.elements[i + 1]]); //create interfaces joining each neighbouring element
		f.buildVelos();
		this.interfaces.push(f);
	}
	
	this.updateEndX();
	
	return this;
	
	
};

Pipe.prototype = {
	diam: 64, //mm
	length: 100, //mm
	posX: 0,
	angle: 0,
	label: "",
	
	resetMassFlows: function(){
		for(var i = 0, l = this.elements.length; i < l; i++){  //reset mass flows to zero for this round of calculations
			this.elements[i].massFlow = 0;
			this.elements[i].peVelos = [];
		}
	},
	
	calculateMassFlows: function(time_scale){
		for(var i = 0, l = this.interfaces.length; i < l; i++){ //calculate mass flows across each interface
			this.interfaces[i].calculateInterfaceMassFlows(time_scale);
		}

	},
	
	update: function(time_scale){
			for(var i = 0, l = this.elements.length; i < l; i++){  //update the mass of each pipe element
			this.elements[i].update(time_scale);
		}
	},
	render: function(ctx){
		for(var i = 0, l = this.elements.length; i < l; i++){
			this.elements[i].render(ctx);
		}
	},
	
	updateEndX: function(){
		var N = this.elements.length;
		this.endX = this.elements[N-1].posX + this.elements[N-1].size;
	},
	
	updateDiam: function(newDiam,elms){
		for(var i = 0, l = elms.length; i < l; i++){
			elms[i].changeDiam(newDiam);
		}
		
	}
	
	
};

var Valve = function(diam, length, posX, posY, setting, id){
	this.oDiam = this.diam;
	this.setting = setting; //0 = closed, 1 = open
	this.diam = this.setting*this.oDiam;
	Pipe.call(this, this.diam, length, posX, posY, 0);
	if(setting == null || setting < 0 || setting > 1){this.setting = 0;}
	this.id = id;
	if(id == null){this.id = "valve" + Valves.length}
	this.label = this.id;
	


	var mid = Math.round(this.elements.length/2);
	this.elements[mid].label = this.label;
	
	Valves.push(this); //add to the global list of Valves, for auto-naming
	Controls.push(this);
	this.SN = Controls.length - 1;
	
	var controlPanel = document.getElementById("valves");
	controlPanel.innerHTML += '<label for="'+ this.id + 'control">Setting: '+ this.id + '</label>';
	controlPanel.innerHTML += '<input type="range" id="' + this.id + 'control" class="comptrol" min = "0" max = "1" step = "0.01" value="' + this.setting + '" data-connectedto="' + this.SN + '">';
	controlPanel.innerHTML += '<span id="'+ this.id + 'controlDisplay">' + this.setting*100 + '%</span>';
	

	
}

Valve.prototype = Object.create(Pipe.prototype);
Valve.prototype.applySliderValue = function(val){
	this.setting = val;
	document.getElementById(this.id + "controlDisplay").innerHTML = Math.round(val*100) + "%";
	this.diam = this.oDiam*this.setting;
	this.updateDiam(this.diam, this.elements);
	
}
Valve.constructor = Valve;


var Interface = function(elms){
	this.elements = elms;
	this.velos = [];
	this.buildVelos();
	this.interfaceActive = true;
	
}

Interface.prototype = {
	buildVelos: function(){ //build an NxN matrix to contain speeds across each pair of elements
		this.velos = [];
		for(var i = 0; i < this.elements.length; i++){
			var sub = [];
			for(var j = 0; j < this.elements.length; j++){
				sub.push(0);
			}
			this.velos.push(sub);
		}	
	},


	calculateInterfaceMassFlows: function(time_scale){
		if(this.elements.length > 0){
			for(var i = 0, l = this.elements.length; i < l - 1; i++){
				for(var j = i + 1; j < l; j++){
					var A = this.elements[i];
					var B = this.elements[j];
			
					if(Math.abs(A.pressure - B.pressure) > 0 || A.isPump || B.isPump){
					
						var workingArea = Math.min(A.area,B.area)/1e6;  //find size of interface between pipe elements, then convert to m^2
						var F = 1000*(A.pressure - B.pressure)*workingArea;  //find net force in direction of B, Newtons
						
						if(A.mass > 0){
							var aA = (F/A.mass)/time_scale; //resultant acceleration of fluid in ms^-2
						} else {
							var aA = (F/B.mass)/time_scale;
						}
						if(B.mass > 0){
							var aB = (F/B.mass)/time_scale; //resultant acceleration of fluid in ms^-2
						} else { var aB = (F/A.mass)/time_scale; }
					
						if(A.isPump){
							if(aB < 0){aB = 0};
						}
						if(B.isPump){
							if(aA > 0){aA = 0};
						}
					
						var kA = Math.pow(0.991,60000/time_scale);
						var kB = Math.pow(0.991,60000/time_scale);
					
				
						var veloAtoB = kA*this.velos[i][j] + aA;
						var veloBfromA = kB*this.velos[j][i] + aB;
			
						if(A.isSink){
							A.massFlow -= (veloAtoB/time_scale)*(B.area/1000)*A.density;
						} else {
							A.massFlow -= (veloAtoB/time_scale)*(A.area/1000)*A.density;  //g of mass flow during time interval
						}
						if(B.isSink){
							B.massFlow += (veloBfromA/time_scale)*(A.area/1000)*B.density;
						} else {
							B.massFlow += (veloBfromA/time_scale)*(B.area/1000)*B.density;
						}
	

						this.velos[i][j] = veloAtoB;
						this.velos[j][i] = veloBfromA;
						A.peVelos.push(veloAtoB);
						B.peVelos.push(veloBfromA);
					}
				}
			}
		}
	}
}

var PipeElement = function(diam, length, posX, posY) {
    this.diam = diam;
	this.length = length; //mm
	this.posX = posX;
	this.posY = posY;
	
	this.area = (Math.PI*diam*diam*0.25);
	this.volume = this.area*this.length; //mm^3
	this.mass = this.volume*this.density/1000; //cross-sectional area * length * density in g/mm^3
	this.size = this.length;
	this.peVelos = [];

    return this;
};




PipeElement.prototype = {
    diam: 64, //mm
	length: 1, //mm
	area: 1, //mm^2
	volume: 1, //cm^3
	mass: 1, //g
	pressure: 0, //gauge pressure, Pa
	density: 1, //g/cm^3
	massFlow: 0, //g, positive is IN
	isPump: false,
	isSink: false,
	
	//RENDERING VARIABLES
	posX: 0,
	posY: 0,
	label: "",
	colour: "rgba(0, 0, 0, 1)",
	size: 20,  //size for rendering will depend on how many elements there are, and aesthetic considerations!


	changeDiam: function(newDiam){
		this.diam = newDiam;
		this.area = (Math.PI*this.diam*this.diam*0.25);
		this.volume = this.area*this.length; //mm^3
		this.mass = this.volume*this.density/1000;
		if(this.diam <= 0){this.pressure = 0;}
		//this.density = 1000*this.mass/this.volume //cross-sectional area * length * density in g/mm^3;
	},
	
	
	densityFromPressure: function() {
		
		this.density = rho/(1 - (this.pressure - pAtmo)/K);
		this.mass = this.density*this.volume/1000;
	},

	
	update: function() {
		this.mass = this.mass + this.massFlow;
		if(this.mass < 0){this.mass = 1;}
		var oldDensity = this.density;
		if(this.mass !=0){this.density = this.mass/(this.volume/1000)};
		var oldPressure = this.pressure;
		this.pressure = K*(1 - (oldDensity/this.density)) + oldPressure;
		this.velo = this.findVelo();
		this.colour = "hsla(200, 100%, " + 100*(this.pressure - 100000)/1400000 +"%, 1)" //pressure range between 2550000 and 0

	},
	
	findVelo: function(){
		var avg = 0;
		for(var i = 0, l = this.peVelos.length; i < l; i++){
			avg += this.peVelos[i]/l;
		}
		return avg;
			
	},

	
	
	render: function(ctx) {
        ctx.fillStyle= this.colour;
		ctx.strokeStyle = "rgba(255,255,255,0.4)";
		ctx.lineWidth = 1;
		ctx.fillStyle= this.colour;
		ctx.beginPath();
		ctx.save();
		ctx.translate(this.posX - 0.5*this.size, this.posY - 0.5*this.diam);
		ctx.rect(0,0, this.size, this.diam);
		ctx.fill();
		ctx.restore();
		ctx.font="9px Arial";
		ctx.fillText(this.label, this.posX - 0.5*this.size, this.posY - 120);
		ctx.fillText("p: " + Math.round(this.pressure/1000) + "kPa", this.posX - 0.5*this.size, this.posY - 100);
		ctx.fillText("mass: " + Math.round(this.mass)+ "g", this.posX - 0.5*this.size, this.posY - 80);
		ctx.fillText("q: " + Math.round(60*this.massFlow*timescale*physicsSteps)+ "L/m", this.posX - 0.5*this.size, this.posY - 60);
		ctx.fillText("v: " + this.velo.toFixed(2) + "m/s", this.posX - 0.5*this.size, this.posY - 40);


	}
	
};

var Sink = function(diam, length, posX, posY, id){
	PipeElement.call(this, diam, length, posX, posY);
	this.id = id;
	if(id == null){this.id = "sink" + Sinks.length}
	this.label = this.id;
	
	Sinks.push(this);
	
}

Sink.prototype = Object.create(PipeElement.prototype);
Sink.prototype.colour = "rgba(0,0,0,1)";
Sink.prototype.isSink = true;
Sink.prototype.update = function() {
		this.mass = 0;
		this.pressure = pAtmo;
		this.density = rho;
		this.velo = this.findVelo();
		
	}
Sink.constructor = Sink;

var Pump = function(diam, length, power, posX, posY, id){
	PipeElement.call(this, diam, length, posX, posY);
	this.power = power; //Js^-1
	this.id = id;
	if(id == null){this.id = "pump" + Pumps.length}
	this.label = this.id;

	Pumps.push(this); //add to the global list of Pumps, for auto-naming
	Controls.push(this);
	this.SN = Controls.length - 1;
	
	var controlPanel = document.getElementById("throttles");
	controlPanel.innerHTML += '<label for="'+ this.id + 'throttle" >Throttle: '+ this.id + '</label>';
	controlPanel.innerHTML += '<input type="range" id="' + this.id + 'throttle" class="comptrol" min = "0" max = "100" step = "0.10" value="' + this.power + '" data-connectedto="'+ this.SN +'" >';
	controlPanel.innerHTML += '<span id="'+ this.id + 'throttleDisplay">' + this.power + '</span>';
	

}

Pump.prototype = Object.create(PipeElement.prototype);
Pump.prototype.isPump = true;
Pump.prototype.maxPressure = 6000000;
Pump.prototype.colour = "rgba(100,100,100,1)";

Pump.prototype.update = function(time_scale) {
	var massOut = this.massFlow;
	if(this.pressure <= this.maxPressure){
		this.massFlow = this.massFlow + (this.density*1e6/time_scale)*((this.power/this.pressure));
		this.mass = this.mass + this.massFlow;
		if(this.mass < 0){this.mass = 0.001;}
		var oldDensity = this.density;
		this.density = this.mass/(this.volume/1000);
		var oldPressure = this.pressure;
		this.pressure = K*(1 - (oldDensity/this.density)) + oldPressure;
	} else {
		this.pressure = this.maxPressure;
		this.densityFromPressure();
	}
	this.colour = "hsla(200, 100%, " + 100*(this.pressure - 100000)/1400000 +"%, 1)" //pressure range between 2550000 and 0
	this.massFlow = massOut; //for testing of pump output visually
	this.velo = this.findVelo();

	Pump.prototype.updatePower = function(value){
		this.power = value;
	}
		
}

Pump.prototype.applySliderValue = function(val){
	this.power = val;
	document.getElementById(this.id + "throttleDisplay").innerHTML = this.power;
}

Pump.constructor = Pump;

var Controls = [];
var Pumps = [];
var Valves = [];
var Sinks = [];

var elementLength = 30; //mm 
var rho = 1 // density of fluid, g/cm^3
var K = 2e9; //  bulk modulus of fluid, Pa
var timescale = 60; //how many frames are equivalent to 1 second?
var physicsSteps = 100; //how much to subdivide each frame for finer (more accurate?) calculations. 

while(timescale*physicsSteps*elementLength < 120000){ //Do not let timescale*physicsSteps*elementLength < 60000, oscillations become too nasty!
	physicsSteps *=2;
	elementLength += 2;
	console.log("eL = " + elementLength);
	console.log("pS = " + physicsSteps);

}


var pAtmo = 1e5; //atmospheric pressure, Pa
var thisPipe = new Pipe(64, 800, 0, height/4, 0);
var thatPipe = new Pipe(64, 800, 0, height/2, 0);
var thisValve = new Valve(64, 200, 0, 0.75*height, 0);
var thatValve = new Valve(64, 200, 400, 0.75*height, 0);




for(var i = Math.round(0.4*thisPipe.elements.length); i < Math.round(0.6*thisPipe.elements.length); i++){
	thisPipe.elements[i].changeDiam(64);
}


	thisSink = new Sink(64, elementLength, thisPipe.endX, height/2 - 64);
	SinkInterface = new Interface([thisPipe.elements[thisPipe.elements.length - 1],thatPipe.elements[thisPipe.elements.length - 1], thisSink]);
	
	thisPipe.elements.push(thisSink);
	thisPipe.interfaces.push(SinkInterface);
	thisPipe.updateEndX();
	
	thisPump = new Pump(64, elementLength, 10, thisPipe.elements[0].posX - elementLength, height/2 - 64);
	thisPump.pressure = 0;
	thisPump.densityFromPressure();
	PumpInterface = new Interface([thisPump, thisValve.elements[0], thatValve.elements[0]]);
	
	thisValveInterface = new Interface([thisValve.elements[thisValve.elements.length - 1],thisPipe.elements[0]]);
	thatValveInterface = new Interface([thatValve.elements[thisValve.elements.length - 1],thatPipe.elements[0]]);
	
	
	thisPipe.elements.unshift(thisPump);	// not that the pipe is actually connected (interface-wise) to the pump, but it's a convenient way to get the pump iterated through for now (can't add it to the Valve elements because of the dynamic diameter!)
	thisPipe.interfaces.unshift(thisValveInterface); //
	thatPipe.interfaces.unshift(thatValveInterface); //it actually doesn't matter at the moment where the interfaces are stored, as long as they are iterated through
	thisPipe.interfaces.unshift(PumpInterface);


	//this is an entirely cumbersome way to build the network! Please streamline (perhaps making 'NETWORK' objects)
	
	

	
	   
function drawWorld(){   ///main animation loop

	ctx0.fillStyle = "rgba(100,0,100,1)";
	ctx0.fillRect(0,0,width,height);
	for(var j = 0; j < physicsSteps; j++){
		thisPipe.resetMassFlows();	
		thatPipe.resetMassFlows();
		thisValve.resetMassFlows();
		thatValve.resetMassFlows();
		thisPipe.calculateMassFlows(timescale*physicsSteps);
		thatPipe.calculateMassFlows(timescale*physicsSteps);
		thisValve.calculateMassFlows(timescale*physicsSteps);
		thatValve.calculateMassFlows(timescale*physicsSteps);
		thisPipe.update(timescale*physicsSteps);
		thatPipe.update(timescale*physicsSteps);
		thisValve.update(timescale*physicsSteps);
		thatValve.update(timescale*physicsSteps);
		//again, cumbersome - should be grouped into NETWORKS

		
	}
	ctx1.clearRect(0,0,width,height);
	
	thisPipe.render(ctx1);
	thatPipe.render(ctx1);
	thisValve.render(ctx1);
	thatValve.render(ctx1);
	ctx0.drawImage(canvas1,0,0);
	requestAnimationFrame(drawWorld);
}
console.log("All good!");
drawWorld();





</script>
</body>
