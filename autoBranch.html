<!DOCTYPE html>
<html>
 <!-- Simulation of the operation of an automatic firefighting branch, e.g. TFT -->
 <!-- Attempt to use a simplified fluid flow model to adjust pressures/flow rates throughout a section of hose, valves and other infrastructure -->
 <!-- Created by Tristan Miller, May 2018 -->
 <!-- Download and then open in your browser. -->
<head>
<meta charset="utf-8">
<title>Automatic Branch Simulation</title>
<style>

//this CSS is terrible and I feel bad about it
canvas {
    border: 0px #CCC solid;
}

input[type="checkbox"]
{
  /* Double-sized Checkboxes */
  -ms-transform: scale(2); /* IE */
  -moz-transform: scale(2); /* FF */
  -webkit-transform: scale(2); /* Safari and Chrome */
  -o-transform: scale(2); /* Opera */
  padding: 10px;
}

#controls
{
  font-size: 110%;
  display: inline;
  padding:5px;
  padding-top: 0px;
}

label
{
 padding: 15px;
 padding-right: 2px;
}

div, button
{
 margin: 5px;
 margin-left:10px;
}

h2
{
 padding:0px;
 margin:0px;
}


</style>
</head>
<body>
<h1 id="theTitle">AutoBranch</h1>
<h2 id="status">0 | 0</h2>

<canvas id="canvas0" height="1024" width="1024">This text is displayed if your browser don't support HTML5 Canvas!</canvas>

<script>

	var title = document.querySelector("#theTitle");
	var canvas0 = document.querySelector("#canvas0");
	var ctx0 = canvas0.getContext("2d");

	var width = canvas0.width; //main dimensions of the 'world' - canvas0 is the 'base layer' of the animation
	var height = canvas0.height;
	
	//create canvases that never appear onscreen or in the DOM but are used for layered rendering
	var canvas1 = document.createElement("canvas");
	canvas1.width = width;
	canvas1.height = height;
	var ctx1 = canvas1.getContext("2d");

	var canvas2 = document.createElement("canvas");
	canvas2.width = width;
	canvas2.height = height;
	var ctx2 = canvas2.getContext("2d");

	var canvas3 = document.createElement("canvas");
	canvas3.width = width;
	canvas3.height = height;
	var ctx3 = canvas3.getContext("2d");
	
	
//OBJECTS NEEDED
//Pipe element
/* 	fluid velocity
	fluid pressure
	fluid density
	mass of fluid in that section
	fluid resistance (function of fluid velocity)
	pressure drop across element (function of fluid velocity and fluid resistance)
	connections to other elements
	flow in
	flow out
*/

//Pipe 'network'
/*	Ordered list of pipe elements to imply connections betweeen elements
	This connectivity will hopefully end up being embedded in the pipe elements themselves -
	leaving this as a means of grouping elements that are in important sub-sections of the pipe network

*/




var PipeElement = function(diam, length, posX, posY) {
    this.diam = diam;
	this.length = length;
	this.posX = posX;
	this.posY = posY;
	this.volume = (Math.PI*diam*diam*0.25)*this.length
	this.mass = this.volume*this.density/1000; //cross-sectional area * length * density in g/mm^3
	this.size = this.length * 10;

    return this;
};


PipeElement.prototype = {
    diam: 64, //mm
	length: 1, //mm
	volume: 1, //cm^3
	mass: 1, //kg
	pressure: 0, //gauge pressure, Pa
	density: 1, //g/cm^3
	massFlowL: 0, //g, positive is IN from the LEFT
	massFlowR: 0, //g, positive is OUT to the RIGHT
	veloL: 0, //ms^-1, velocity of fluid at LHS interface, positive is IN
	veloR: 0, //ms^-1, velocity of fluid at RHS interface, positive is OUT
	fluidResL: 0, //fluid resistive force at LHS interface - depends on veloL and pipe diameter
	fluidResR: 0, //fluid resistive force at RHS interface - depends on veloR and pipe diameter
	//also, these left and right terms will later be replaced by an array representing connections to other elements
	//RENDERING VARIABLES
	posX: 0,
	posY: 0,
	label: "",
    //square: false,
	colour: "rgba(0, 0, 0, 1)",
	size: 20,  //size for rendering will depend on how many elements there are, and aesthetic considerations!



	
	update: function() {
		this.mass = this.mass + this.massFlowL - this.massFlowR;
		this.density = this.mass/this.volume;

	},
	
	
	render: function(ctx) {
        ctx.fillStyle= this.colour;
		ctx.strokeStyle = "rgba(255,255,255,0.4)";
		ctx.lineWidth = 1;
		ctx.fillStyle= this.colour;
		ctx.beginPath();
		ctx.save();
		ctx.translate(this.posX - 0.5*this.size, this.posY - 0.5*this.size);
		ctx.rect(0,0, this.size, this.size);
		ctx.fill();
		ctx.stroke();
		ctx.restore();
		ctx.font="20px Arial";
		ctx.fillText(this.pressure, this.posX, this.posY - 50);

	}
	//the following is dross from another program!
	/*update: function() {
		this.posX = this.posX + this.velX;
		this.posY = this.posY + this.velY;
		this.size = 2*this.mass;

		if(this.square){
		this.ang = (this.ang + this.rot)%360;
		}

		if(this.walls){
			if((this.velX > 0 && this.posX > width) || (this.velX < 0 && this.posX < 0)){
				this.velX = -0.7*this.velX;
			}
			if((this.velY > 0 && this.posY > height) || (this.velY < 0 && this.posY < 0)){
				this.velY = -0.7*this.velY;
			}
		}
		this.iList = [];
	}*/
};

var rho = 1.0 // density of fluid, g/cm^3
var K = 2e9; //  bulk modulus of fluid, Pa
var Pipe = [];
var N = 7; //number of elements in pipe

for (var i = 0; i < N; i++){
	var X;
	if(i == 0){X = 100;} else {X = Pipe[i - 1].posX + Pipe[i - 1].size + 5}
	var p = new PipeElement(64, 5, X, height/2);
	Pipe.push(p);
}



var ctr = 0;
	   
function drawWorld(){   ///main animation loop
	ctx0.fillStyle = "rgba("+ (155 - (ctr%155)) + ",0,"+ ctr%155 +",1)";
	ctx0.fillRect(0,0,width,height);
	
	ctx1.clearRect(0,0,width,height);
	for (var i = 0; i < N; i++){
		Pipe[i].render(ctx1);
	}
	ctx0.drawImage(canvas1,0,0);
	
	ctr = 0;
	
	
	requestAnimationFrame(drawWorld);
}
console.log("All good!");
drawWorld();
</script>
</body>
