<!DOCTYPE html>
<html>
 <!-- Simulation of the operation of an automatic firefighting branch, e.g. TFT -->
 <!-- Attempt to use a simplified fluid flow model to adjust pressures/flow rates throughout a section of hose, valves and other infrastructure -->
 <!-- Created by Tristan Miller, May 2018 -->
 <!-- Download and then open in your browser. -->
<head>
<meta charset="utf-8">
<title>Automatic Branch Simulation</title>
<style>

//this CSS is terrible and I feel bad about it
canvas {
    border: 0px #CCC solid;
}

input[type="checkbox"]
{
  /* Double-sized Checkboxes */
  -ms-transform: scale(2); /* IE */
  -moz-transform: scale(2); /* FF */
  -webkit-transform: scale(2); /* Safari and Chrome */
  -o-transform: scale(2); /* Opera */
  padding: 10px;
}

#controls
{
  font-size: 110%;
  display: inline;
  padding:5px;
  padding-top: 0px;
}

label
{
 padding: 15px;
 padding-right: 2px;
}

div, button
{
 margin: 5px;
 margin-left:10px;
}

h2
{
 padding:0px;
 margin:0px;
}


</style>
</head>
<body>
<h1 id="theTitle">AutoBranch</h1>
<h2 id="status">0 | 0</h2>

<canvas id="canvas0" height="1024" width="1024" onclick="requestAnimationFrame(drawWorld)">This text is displayed if your browser don't support HTML5 Canvas!</canvas>

<script>

	var title = document.querySelector("#theTitle");
	var canvas0 = document.querySelector("#canvas0");
	var ctx0 = canvas0.getContext("2d");

	var width = canvas0.width; //main dimensions of the 'world' - canvas0 is the 'base layer' of the animation
	var height = canvas0.height;
	
	//create canvases that never appear onscreen or in the DOM but are used for layered rendering
	var canvas1 = document.createElement("canvas");
	canvas1.width = width;
	canvas1.height = height;
	var ctx1 = canvas1.getContext("2d");

	var canvas2 = document.createElement("canvas");
	canvas2.width = width;
	canvas2.height = height;
	var ctx2 = canvas2.getContext("2d");

	var canvas3 = document.createElement("canvas");
	canvas3.width = width;
	canvas3.height = height;
	var ctx3 = canvas3.getContext("2d");
	
	
//OBJECTS NEEDED
//Pipe element
/* 	fluid velocity
	fluid pressure
	fluid density
	mass of fluid in that section
	fluid resistance (function of fluid velocity)
	pressure drop across element (function of fluid velocity and fluid resistance)
	connections to other elements
	flow in
	flow out
*/

//Pipe 'network'
/*	Ordered list of pipe elements to imply connections betweeen elements
	This connectivity will hopefully end up being embedded in the pipe elements themselves -
	leaving this as a means of grouping elements that are in important sub-sections of the pipe network

*/

var Pipe = function(diam, length) {
	this.diam = diam; 		//mm
	this.length = length; 	//mm
	
	return this;
};

Pipe.prototype = {
	diam: 64, //mm
	length: 100, //mm
	
	
	
};


var PipeElement = function(diam, length, posX, posY) {
    this.diam = diam;
	this.length = length; //mm
	this.posX = posX;
	this.posY = posY;
	
	this.area = (Math.PI*diam*diam*0.25);
	this.volume = this.area*this.length; //mm^3
	this.mass = this.volume*this.density/1000; //cross-sectional area * length * density in g/mm^3
	this.size = this.length;

    return this;
};


PipeElement.prototype = {
    diam: 64, //mm
	length: 1, //mm
	area: 1, //mm^2
	volume: 1, //cm^3
	mass: 1, //kg
	pressure: 0, //gauge pressure, Pa
	density: 1, //g/cm^3
	massFlowL: 0, //g, positive is IN from the LEFT
	massFlowR: 0, //g, positive is OUT to the RIGHT
	veloL: 0, //ms^-1, velocity of fluid at LHS interface, positive is IN
	veloR: 0, //ms^-1, velocity of fluid at RHS interface, positive is OUT
	k: 0, //friction coefficient;
	fluidResL: 0, //fluid resistive force at LHS interface - depends on veloL and pipe diameter
	fluidResR: 0, //fluid resistive force at RHS interface - depends on veloR and pipe diameter
	//also, these left and right terms will later be replaced by an array representing connections to other elements
	//RENDERING VARIABLES
	posX: 0,
	posY: 0,
	label: "",
    //square: false,
	colour: "rgba(0, 0, 0, 1)",
	size: 20,  //size for rendering will depend on how many elements there are, and aesthetic considerations!


	changeDiam: function(newDiam){
		this.diam = newDiam;
		this.area = (Math.PI*this.diam*this.diam*0.25);
		this.volume = this.area*this.length; //mm^3
		this.mass = this.volume*this.density/1000;
		//this.density = 1000*this.mass/this.volume //cross-sectional area * length * density in g/mm^3;
	},

	
	update: function() {
		this.mass = this.mass + this.massFlowL - this.massFlowR;
		var oldDensity = this.density;
		this.density = this.mass/(this.volume/1000);
		var oldPressure = this.pressure;
		this.pressure = K*(1 - (oldDensity/this.density)) + oldPressure;
		this.colour = "hsla(" + 200*(this.pressure - 100000)/900000 +", 100%, 50%, 1)" //pressure range between 2550000 and 0

	},
	
	densityFromPressure: function() {
		
		this.density = rho/(1 - (this.pressure - pAtmo)/K);
		this.mass = this.density*this.volume/1000;
	},
	
	
	render: function(ctx) {
        ctx.fillStyle= this.colour;
		ctx.strokeStyle = "rgba(255,255,255,0.4)";
		ctx.lineWidth = 1;
		ctx.fillStyle= this.colour;
		ctx.beginPath();
		ctx.save();
		ctx.translate(this.posX - 0.5*this.size, this.posY - 0.5*this.diam);
		ctx.rect(0,0, this.size, this.diam);
		ctx.fill();
		ctx.stroke();
		ctx.restore();
		ctx.font="9px Arial";
		ctx.fillText("p: " + Math.round(this.pressure/1000) + "kPa", this.posX - 0.5*this.size, this.posY - 100);
		ctx.fillText("mass: " + Math.round(this.mass)+ "g", this.posX - 0.5*this.size, this.posY - 80);
		ctx.fillText("In: " + Math.round(60*this.massFlowL*timescale*physicsSteps/1000)+ "L/m", this.posX - 0.5*this.size, this.posY - 60);
		ctx.fillText("Out: " + Math.round(60*this.massFlowR*timescale*physicsSteps/1000)+ "L/m", this.posX - 0.5*this.size, this.posY - 40);

	}
	
};

var rho = 1 // density of fluid, g/cm^3
var K = 2e9; //  bulk modulus of fluid, Pa
var timescale = 600000; //how many frames are equivalent to 1 second?
var physicsSteps = 100; //how much to subdivide each frame for finer (more accurate?) calculations
//consider also having within this a physics step time - do multiple (small) updates in a single frame
//to avoid overshoots
var pAtmo = 1e5; //atmospheric pressure, Pa
var thisPipe = [];
var N = 400; //number of elements in pipe
var POW = 10000; //watts of pump power

for (var i = 0; i < N; i++){
	var X;
	if(i == 0){X = 100;} else {X = thisPipe[i - 1].posX + thisPipe[i - 1].size + 0}
	var p = new PipeElement(64, 2, X, height/2);
	p.pressure = pAtmo;
	console.log("Mass of element " + i + " = " + p.mass + " :-)");
	thisPipe.push(p);
}
//thisPipe[7].pressure = 1000000;
//thisPipe[0].changeDiam(25);
//thisPipe[1].changeDiam(52);
//thisPipe[2].changeDiam(80);
//thisPipe[3].changeDiam(100);
//thisPipe[4].changeDiam(100);
//thisPipe[5].changeDiam(80);
//thisPipe[6].changeDiam(25);
//thisPipe[7].changeDiam(52);
//thisPipe[8].changeDiam(38);
//thisPipe[9].changeDiam(10);
//thisPipe[10].changeDiam(25);
//thisPipe[11].changeDiam(38);
//thisPipe[12].changeDiam(38);
//thisPipe[13].changeDiam(38);
//thisPipe[N-2].changeDiam(10);

var thisPCU = [];
var thisPCUElements = 100;
if(thisPCUElements > thisPipe.length - 2 ){
	thisPCUElements = thisPipe.length - 2;
}
for(var i = 0; i < thisPCUElements; i++){
	thisPCU.push(thisPipe[N - 1 - thisPCUElements + i]);
}

//var altPipe = new PipeElement(38, 50, Pipe[8].posX, Pipe[8].posY);
//altPipe.pressure = pAtmo;
//thisPipe[8] = altPipe;

	   
function drawWorld(){   ///main animation loop
	ctx0.fillStyle = "rgba(100,0,100,1)";
	ctx0.fillRect(0,0,width,height);
	for(var j = 0; j < physicsSteps; j++ ){
		for (var i = 0; i < N; i++){
			if(i == 0){
				//thisPipe[i].massFlowL = ((1e5/6)/timescale)/physicsSteps; //approx 1000 L/min
				thisPipe[i].massFlowL = thisPipe[i].density*1e6*((POW/thisPipe[i].pressure)/timescale)/physicsSteps;
			} else {
				calculateElementMassFlows(thisPipe[i - 1], thisPipe[i]);
			} 
			thisPipe[i].update(ctx1);
		}

		thisPipe[N - 1].massFlowR = thisPipe[N - 1].massFlowL;
	}
		
	ctx1.clearRect(0,0,width,height);
	
		var totalMass = 0;
	for (var i = 0; i < N; i++){
		thisPipe[i].render(ctx1);
		totalMass += thisPipe[i].mass;
	}
	
	var nozDiff = thisPipe[N - 2 - thisPCUElements].pressure - thisPipe[N-1].pressure;
	var nozDiam = thisPipe[N-2].diam;
	for(var i=0; i < thisPCUElements; i++){
		if(nozDiff > 800000){
			if(nozDiff < 750000){
				thisPCU[i].changeDiam(nozDiam*1.0001);
			} else {
				thisPCU[i].changeDiam(nozDiam*1.001);
			}
		}
		if(nozDiff < 600000){
			if(nozDiff > 650000){
				thisPCU[i].changeDiam(nozDiam*0.9999);
			} else {
				thisPCU[i].changeDiam(nozDiam*0.999);
			}
		}
		
	}

	//console.log(nozDiff);
	
	
	ctx0.drawImage(canvas1,0,0);
	
	//console.log(totalMass);	
	requestAnimationFrame(drawWorld);
}
console.log("All good!");
drawWorld();

function calculateElementMassFlows(peL,peR){
	var pL = peL.pressure;
	var pR = peR.pressure;
	var workingArea = Math.min(peL.area,peR.area)/1e6;  //find size of interface between pipe elements, then convert to m^2
	var FL = pL*workingArea - peL.k*peL.veloR*peL.veloR; // F is in Newtons
	var FR = pR*workingArea - peR.k*peR.veloL*peR.veloL; //F is in Newtons
	var F = FL - FR; //meaning that a net force to the right will be positive
	var aL = (F/peL.mass); //resultant acceleration of fluid in ms^-2
	var aR = (F/peR.mass); //resultant acceleration of fluid in ms^-2
	aL = aL/(timescale*physicsSteps);
	aR = aR/(timescale*physicsSteps);

	peL.veloR = (1 - 100/(timescale*physicsSteps))*peL.veloR + aR;
	peR.veloL = (1 - 100/(timescale*physicsSteps))*peR.veloL + aL;
	peL.massFlowR = (peL.veloR)*(peL.area/1000)*peL.density;
	peR.massFlowL = (peR.veloL)*(peR.area/1000)*peR.density;
	var massFlow = Math.min(Math.abs(peL.massFlowR, peR.massFlowL));
	peL.massFlowR = Math.sign(peL.massFlowR)*massFlow;
	peR.massFlowL = peL.massFlowR; //all about continuity of mass over the boundary between the elements. This chooses the smallest mass flow of the two to be applied to both.
	
}




</script>
</body>
