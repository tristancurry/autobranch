<!DOCTYPE html>
<html>
 <!-- Simulation of the operation of an automatic firefighting branch, e.g. TFT -->
 <!-- Attempt to use a simplified fluid flow model to adjust pressures/flow rates throughout a section of hose, valves and other infrastructure -->
 <!-- Created by Tristan Miller, May 2018 -->
 <!-- Download and then open in your browser. -->
<head>
<meta charset="utf-8">
<title>Automatic Branch Simulation</title>
<style>

//this CSS is terrible and I feel bad about it
canvas {
    border: 0px #CCC solid;
}

input[type="checkbox"]
{
  /* Double-sized Checkboxes */
  -ms-transform: scale(2); /* IE */
  -moz-transform: scale(2); /* FF */
  -webkit-transform: scale(2); /* Safari and Chrome */
  -o-transform: scale(2); /* Opera */
  padding: 10px;
}

#controls
{
  font-size: 110%;
  display: inline;
  padding:5px;
  padding-top: 0px;
}

label
{
 padding: 15px;
 padding-right: 2px;
}

div, button
{
 margin: 5px;
 margin-left:10px;
}

h2
{
 padding:0px;
 margin:0px;
}


</style>
</head>
<body>
<h1 id="theTitle">AutoBranch</h1>
<h2 id="status">0 | 0</h2>

<canvas id="canvas0" height="1024" width="1024" onclick="requestAnimationFrame(drawWorld)">This text is displayed if your browser don't support HTML5 Canvas!</canvas>

<script>

	var title = document.querySelector("#theTitle");
	var canvas0 = document.querySelector("#canvas0");
	var ctx0 = canvas0.getContext("2d");

	var width = canvas0.width; //main dimensions of the 'world' - canvas0 is the 'base layer' of the animation
	var height = canvas0.height;
	
	//create canvases that never appear onscreen or in the DOM but are used for layered rendering
	var canvas1 = document.createElement("canvas");
	canvas1.width = width;
	canvas1.height = height;
	var ctx1 = canvas1.getContext("2d");

	var canvas2 = document.createElement("canvas");
	canvas2.width = width;
	canvas2.height = height;
	var ctx2 = canvas2.getContext("2d");

	var canvas3 = document.createElement("canvas");
	canvas3.width = width;
	canvas3.height = height;
	var ctx3 = canvas3.getContext("2d");
	
	
//OBJECTS NEEDED
//Pipe element
/* 	fluid velocity
	fluid pressure
	fluid density
	mass of fluid in that section
	fluid resistance (function of fluid velocity)
	pressure drop across element (function of fluid velocity and fluid resistance)
	connections to other elements
	flow in
	flow out
*/

//Pipe 'network'
/*	Ordered list of pipe elements to imply connections betweeen elements
	This connectivity will hopefully end up being embedded in the pipe elements themselves -
	leaving this as a means of grouping elements that are in important sub-sections of the pipe network

*/

	var rho = 1.0 // density of fluid, g/cm^3
	var K = 2e9; //  bulk modulus of fluid, Pa


var PipeElement = function(diam, length, posX, posY) {
    this.diam = diam;
	this.length = length; //mm
	this.posX = posX;
	this.posY = posY;
	
	this.area = (Math.PI*diam*diam*0.25);
	this.volume = this.area*this.length; //mm^3
	this.mass = this.volume*this.density/1000; //cross-sectional area * length * density in g/mm^3
	this.size = this.length;

    return this;
};


PipeElement.prototype = {
    diam: 64, //mm
	length: 1, //mm
	area: 1, //mm^2
	volume: 1, //cm^3
	mass: 1, //kg
	pressure: 0, //gauge pressure, Pa
	density: 1, //g/cm^3
	massFlowL: 0, //g, positive is IN from the LEFT
	massFlowR: 0, //g, positive is OUT to the RIGHT
	veloL: 0, //ms^-1, velocity of fluid at LHS interface, positive is IN
	veloR: 0, //ms^-1, velocity of fluid at RHS interface, positive is OUT
	fluidResL: 0, //fluid resistive force at LHS interface - depends on veloL and pipe diameter
	fluidResR: 0, //fluid resistive force at RHS interface - depends on veloR and pipe diameter
	//also, these left and right terms will later be replaced by an array representing connections to other elements
	//RENDERING VARIABLES
	posX: 0,
	posY: 0,
	label: "",
    //square: false,
	colour: "rgba(0, 0, 0, 1)",
	size: 20,  //size for rendering will depend on how many elements there are, and aesthetic considerations!




	
	update: function() {
		
		
		//console.log("old mass = " + this.mass);
		this.mass = this.mass + this.massFlowL - this.massFlowR;
		//console.log("new mass = " + this.mass);
		//console.log("-----");
		var oldDensity = this.density;
		this.density = this.mass/(this.volume/1000);
		var oldPressure = this.pressure;
		this.pressure = K*(1 - (oldDensity/this.density)) + oldPressure;
		//console.log(oldPressure - this.pressure);
		this.colour = "hsla(100, 0%, " + (this.pressure+1000)/1000 +"%, 1)" //pressure range between 2550000 and 0

	},
	
	densityFromPressure: function() {
		
		this.density = rho/(1 - this.pressure/K);
		this.mass = this.density*this.volume/1000;
	},
	
	
	render: function(ctx) {
        ctx.fillStyle= this.colour;
		ctx.strokeStyle = "rgba(255,255,255,0.4)";
		ctx.lineWidth = 1;
		ctx.fillStyle= this.colour;
		ctx.beginPath();
		ctx.save();
		ctx.translate(this.posX - 0.5*this.size, this.posY - 0.5*this.size);
		ctx.rect(0,0, this.size, this.diam);
		ctx.fill();
		ctx.stroke();
		ctx.restore();
		ctx.font="9px Arial";
		ctx.fillText(Math.round(this.pressure/1000) + "kPa", this.posX - 0.5*this.size, this.posY - 100);
		ctx.fillText(Math.round(this.mass)+ "g", this.posX - 0.5*this.size, this.posY - 70);

	}
	
};

var rho = 1.0 // density of fluid, g/cm^3
var K = 2e9; //  bulk modulus of fluid, Pa
var Pipe = [];
var N = 3; //number of elements in pipe

for (var i = 0; i < N; i++){
	var X;
	if(i == 0){X = 100;} else {X = Pipe[i - 1].posX + Pipe[i - 1].size + 5}
	var p = new PipeElement(64, 100, X, height/2);
	p.pressure = 0;
	console.log("Mass of element " + i + " = " + p.mass + " :-)");
	Pipe.push(p);
}

Pipe[1].pressure = 1000000; //Pa
Pipe[1].densityFromPressure();
console.log(Pipe[0].density);
console.log(Pipe[0].mass);


var ctr = 0;
	   
function drawWorld(){   ///main animation loop
	ctx0.fillStyle = "rgba(100,0,100,1)";
	ctx0.fillRect(0,0,width,height);
	
	ctx1.clearRect(0,0,width,height);
	for (var i = 0; i < N; i++){
		if(i == 0){
			calculateElementMassFlowsLeftEnd(Pipe[i], Pipe[i+1]);
		} else
		if(i < (N - 1)){
			calculateElementMassFlows(Pipe[i - 1], Pipe[i], Pipe[i+1]);
		} else
		if(i == (N - 1)){
			calculateElementMassFlowsRightEnd(Pipe[i - 1], Pipe[i]);
		}
		
	}
	
	for (var i = 0; i < N; i++){
		if(i == 0){
			applyOtherElementMassFlowsLeftEnd(Pipe[i], Pipe[i+1]);
		} else
		if(i < (N - 1)){
			applyOtherElementMassFlows(Pipe[i - 1], Pipe[i], Pipe[i+1]);
		} else
		if(i == (N - 1)){
			applyOtherElementMassFlowsRightEnd(Pipe[i - 1], Pipe[i]);
		}
		
		
		
		
		Pipe[i].update(ctx1);
		Pipe[i].render(ctx1);
	}
	ctx0.drawImage(canvas1,0,0);
	
	ctr = 0;
	
	
	//requestAnimationFrame(drawWorld);
}
console.log("All good!");
drawWorld();

function calculateElementMassFlows(peL, pe, peR){
	var pL = peL.pressure;
	var pR = peR.pressure;
	var FL = pL*peL.area/1e6; //get area of contact in m^2, so that F is in Newtons
	var FR = pR*peR.area/1e6; //get area of contact in m^2, so that F is in Newtons
	var F = FL - FR; //meaning that a net force to the right will be positive
	console.log("net force = " + F + "N");
	var a = (F/pe.mass); //resultant acceleration of fluid in ms^-2
	a = a/1e7;

	pe.veloR = pe.veloR + a;
	pe.veloL = pe.veloL + a;
	pe.massFlowR = (pe.veloR)*(pe.area/1000)*pe.density; //this will need to be adjusted by a factor to make it all per time step
	pe.massFlowL = (pe.veloL)*(pe.area/1000)*pe.density; //this will need to be adjusted by a factor to make it all per time step
	
}

function applyOtherElementMassFlows(peL, pe, peR){
	pe.massFlowL = pe.massFlowL + peL.massFlowR;
	pe.massFlowR = pe.massFlowR + peR.massFlowL;
}

function calculateElementMassFlowsLeftEnd(pe, peR){
	var pL = pe.pressure;
	var pR = peR.pressure;
	var FL = pL*pe.area/1e6;
	var FR = pR*peR.area/1e6; //get area of contact in m^2, so that F is in Newtons
	var F = FL - FR; //meaning that a net force to the right will be positive
	console.log("net force = " + F + "N");
	var a = (F/pe.mass); //resultant acceleration of fluid in ms^-2
	a = a/1e7;

	pe.veloR = pe.veloR + a;
	pe.massFlowR = (pe.veloR)*(pe.area/1000)*pe.density; //this will need to be adjusted by a factor to make it all per time step
	
}

function applyOtherElementMassFlowsLeftEnd(pe, peR){
	pe.massFlowR = pe.massFlowR + peR.massFlowL;
}

function calculateElementMassFlowsRightEnd(peL, pe){

	var pL = peL.pressure;
	var pR = pe.pressure
	var FL = pL*peL.area/1e6; //get area of contact in m^2, so that F is in Newtons
	var FR = pR*pe.area/1e6;
	var F = FL - FR; //meaning that a net force to the right will be positive
	console.log("net force = " + F + "N");
	var a = (F/pe.mass); //resultant acceleration of fluid in ms^-2
	a = a/1e7;
	pe.veloL = pe.veloL + a;
	pe.massFlowL = (pe.veloL)*(pe.area/1000)*pe.density; //this will need to be adjusted by a factor to make it all per time step
	
}

function applyOtherElementMassFlowsRightEnd(peL, pe){
	pe.massFlowL = pe.massFlowL + peL.massFlowR;
}

</script>
</body>
