<!DOCTYPE html>
<html>
 <!-- Simulation of the operation of an automatic firefighting branch, e.g. TFT -->
 <!-- Attempt to use a simplified fluid flow model to adjust pressures/flow rates throughout a section of hose, valves and other infrastructure -->
 <!-- Created by Tristan Miller, May 2018 -->
 <!-- Download and then open in your browser. -->
<head>
<meta charset="utf-8">
<title>Automatic Branch Simulation</title>
<style>

//this CSS is terrible and I feel bad about it
canvas {
    border: 0px #CCC solid;
}

input[type="checkbox"]
{
  /* Double-sized Checkboxes */
  -ms-transform: scale(2); /* IE */
  -moz-transform: scale(2); /* FF */
  -webkit-transform: scale(2); /* Safari and Chrome */
  -o-transform: scale(2); /* Opera */
  padding: 10px;
}

#controls
{
  font-size: 110%;
  display: inline;
  padding:5px;
  padding-top: 0px;
}

label
{
 padding: 15px;
 padding-right: 2px;
}

div, button
{
 margin: 5px;
 margin-left:10px;
}

h2
{
 padding:0px;
 margin:0px;
}


</style>
</head>
<body>
<h1 id="theTitle">AutoBranch</h1>
<h2 id="status">0 | 0</h2>

<canvas id="canvas0" height="1024" width="1024" onclick="requestAnimationFrame(drawWorld)">This text is displayed if your browser don't support HTML5 Canvas!</canvas>

<script>

	var title = document.querySelector("#theTitle");
	var canvas0 = document.querySelector("#canvas0");
	var ctx0 = canvas0.getContext("2d");

	var width = canvas0.width; //main dimensions of the 'world' - canvas0 is the 'base layer' of the animation
	var height = canvas0.height;
	
	//create canvases that never appear onscreen or in the DOM but are used for layered rendering
	var canvas1 = document.createElement("canvas");
	canvas1.width = width;
	canvas1.height = height;
	var ctx1 = canvas1.getContext("2d");

	var canvas2 = document.createElement("canvas");
	canvas2.width = width;
	canvas2.height = height;
	var ctx2 = canvas2.getContext("2d");

	var canvas3 = document.createElement("canvas");
	canvas3.width = width;
	canvas3.height = height;
	var ctx3 = canvas3.getContext("2d");
	
	



var Pipe = function(diam, length, posX, angle) {
	this.diam = diam; 		//mm
	this.length = length; 	//mm
	this.posX = posX;
	this.angle = angle; //rotation ccw in radians
	
	var N = Math.round(length/(elementLength));
	
	for (var i = 0; i < N; i++){
		var X;
		if(i == 0){X = 100;} else {X = this.elements[i - 1].posX + this.elements[i - 1].size}
		var p = new PipeElement(this.diam, elementLength, X, height/2); //create a pipe's worth of elements
		p.pressure = pAtmo;
		this.elements.push(p);
	}
		
	for (var i = 0; i < N - 1; i++){
		var f = new Interface(this.elements[i], this.elements[i + 1]); //create interfaces joining each neighbouring element
		f.buildVelos();
		this.interfaces.push(f);
	}
	
	this.endX = this.elements[N-1].posX + this.elements[N-1].size;
	
	return this;
	
	
};

Pipe.prototype = {
	diam: 64, //mm
	length: 100, //mm
	posX: 0,
	angle: 0,
	elements: [],
	interfaces: [],
	label: "",
	
	calculateMassFlows: function(time_scale){
		for(var i = 0; i < this.elements.length; i++){  //reset mass flows to zero for this round of calculations
			this.elements[i].massFlow = 0;
		}
		for(var i = 0; i < this.interfaces.length; i++){ //calculate mass flows across each interface
			this.interfaces[i].calculateInterfaceMassFlows(time_scale);
		}
		for(var i = 0; i < this.elements.length; i++){  //update the mass of each pipe element
			this.elements[i].update();
		}
	},
	
	render: function(ctx){
		for(var i = 0; i < this.elements.length; i++){
			this.elements[i].render(ctx);
		}
	}
	
	
};

var Interface = function(elm1, elm2){
	this.elements = [elm1, elm2];
	this.velos = [];
	
}

Interface.prototype = {
	buildVelos: function(){ //build an NxN matrix to contain speeds across each pair of elements
		for(var i = 0; i < this.elements.length; i++){
			var sub = [];
			for(var j = 0; j < this.elements.length; j++){
				sub.push(0);
			}
			this.velos.push(sub);
		}	
	},


	calculateInterfaceMassFlows: function(time_scale){
		if(this.elements.length > 0){
			for(var i = 0; i < this.elements.length - 1; i++){
				for(var j = i + 1; j < this.elements.length; j++){
					var A = this.elements[i];
					var B = this.elements[j];
					if(Math.abs(A.pressure - B.pressure) > 0){
					
					var workingArea = Math.min(A.area,B.area)/1e6;  //find size of interface between pipe elements, then convert to m^2
					var F = (A.pressure - B.pressure)*workingArea;  //find net force in direction of B, Newtons
	
					var kA = Math.pow(0.9999,60000/time_scale);
					var kB = Math.pow(0.9999,60000/time_scale);
					//console.log("kA = " + kA);
					if(A.mass > 0){
						var aA = (F/A.mass)/time_scale; //resultant acceleration of fluid in ms^-2
					} else {
						var aA = (F/B.mass)/time_scale;
					}
					if(B.mass > 0){
						var aB = (F/B.mass)/time_scale; //resultant acceleration of fluid in ms^-2
					} else {
						var aB = (F/A.mass)/time_scale;
					}
				 
					//aA = Math.sign(aA)*Math.min(Math.abs(aA),0.1);
					//aB = Math.sign(aB)*Math.min(Math.abs(aB),0.1);
					//console.log("mass: " + A.mass);
					//console.log("aAB: " + aA);
				
					var veloAtoB = kA*this.velos[i][j] + aA;
					var veloBfromA = kB*this.velos[j][i] + aB;
					//console.log("vAB: " + veloAtoB);
			
					A.massFlow -= (veloAtoB/time_scale)*(A.area/1000)*A.density;  //g of mass flow during time interval

					B.massFlow += (veloBfromA/time_scale)*(B.area/1000)*B.density;

					this.velos[i][j] = veloAtoB;
					this.velos[j][i] = veloBfromA;
				}
				}
			}
		}
	}
}

var PipeElement = function(diam, length, posX, posY) {
    this.diam = diam;
	this.length = length; //mm
	this.posX = posX;
	this.posY = posY;
	
	this.area = (Math.PI*diam*diam*0.25);
	this.volume = this.area*this.length; //mm^3
	this.mass = this.volume*this.density/1000; //cross-sectional area * length * density in g/mm^3
	this.size = this.length;

    return this;
};




PipeElement.prototype = {
    diam: 64, //mm
	length: 1, //mm
	area: 1, //mm^2
	volume: 1, //cm^3
	mass: 1, //g
	pressure: 0, //gauge pressure, Pa
	density: 1, //g/cm^3
	massFlow: 0, //g, positive is IN
	k: 0, //friction coefficient;
	
	//RENDERING VARIABLES
	posX: 0,
	posY: 0,
	label: "",
	colour: "rgba(0, 0, 0, 1)",
	size: 20,  //size for rendering will depend on how many elements there are, and aesthetic considerations!


	changeDiam: function(newDiam){
		this.diam = newDiam;
		this.area = (Math.PI*this.diam*this.diam*0.25);
		this.volume = this.area*this.length; //mm^3
		this.mass = this.volume*this.density/1000;
		//this.density = 1000*this.mass/this.volume //cross-sectional area * length * density in g/mm^3;
	},
	
	
	densityFromPressure: function() {
		
		this.density = rho/(1 - (this.pressure - pAtmo)/K);
		this.mass = this.density*this.volume/1000;
	},

	
	update: function() {
		this.mass = this.mass + this.massFlow;
		if(this.mass < 0){this.mass = 0.001;}
		var oldDensity = this.density;
		this.density = this.mass/(this.volume/1000);
		var oldPressure = this.pressure;
		this.pressure = K*(1 - (oldDensity/this.density)) + oldPressure;
		this.colour = "hsla(" + 200*(this.pressure - 100000)/900000 +", 100%, 50%, 1)" //pressure range between 2550000 and 0

	},

	
	
	render: function(ctx) {
        ctx.fillStyle= this.colour;
		ctx.strokeStyle = "rgba(255,255,255,0.4)";
		ctx.lineWidth = 1;
		ctx.fillStyle= this.colour;
		ctx.beginPath();
		ctx.save();
		ctx.translate(this.posX - 0.5*this.size, this.posY - 0.5*this.diam);
		ctx.rect(0,0, this.size, this.diam);
		ctx.fill();
		//ctx.stroke();
		ctx.restore();
		ctx.font="9px Arial";
		ctx.fillText("p: " + Math.round(this.pressure/1000) + "kPa", this.posX - 0.5*this.size, this.posY - 100);
		ctx.fillText("mass: " + Math.round(this.mass)+ "g", this.posX - 0.5*this.size, this.posY - 80);
		ctx.fillText("q: " + Math.round(60*this.massFlow*timescale*physicsSteps)+ "L/m", this.posX - 0.5*this.size, this.posY - 60);


	}
	
};

var Sink = function(diam, length, posX, posY){
	PipeElement.call(this, diam, length, posX, posY);

}

Sink.prototype = Object.create(PipeElement.prototype);
Sink.prototype.colour = "rgba(0,0,0,1)";
Sink.prototype.update = function() {
		this.mass = 0;
		this.pressure = pAtmo;
		this.density = rho;
	}


Sink.constructor = Sink;

var elementLength = 30; //mm 
var rho = 1 // density of fluid, g/cm^3
var K = 2e9; //  bulk modulus of fluid, Pa
var timescale = 6; //how many frames are equivalent to 1 second?
var physicsSteps = 100	; //how much to subdivide each frame for finer (more accurate?) calculations. Do not let timescale*physicsSteps < 600, oscillations become too nasty!

while(timescale*physicsSteps*elementLength < 3000){
	physicsSteps *=2;
	elementLength *= 2;
	console.log("eL = " + elementLength);
	console.log("pS = " + physicsSteps);

}

//consider also having within this a physics step time - do multiple (small) updates in a single frame
//to avoid overshoots
var pAtmo = 1e5; //atmospheric pressure, Pa
var POW = 100000; //watts of pump power

var thisPipe = new Pipe(64, 800, 0, 0);
for(var i = 0; i < thisPipe.elements.length/8; i++){
thisPipe.elements[i].pressure = 1000000/(i+1);
thisPipe.elements[i].densityFromPressure();
}

for(var i = Math.round(0.4*thisPipe.elements.length); i < Math.round(0.6*thisPipe.elements.length); i++){
thisPipe.elements[i].changeDiam(1);
}


thisSink = new Sink(64, elementLength, thisPipe.endX, height/2);
sinkInterface = new Interface(thisPipe.elements[thisPipe.elements.length - 1], thisSink);
sinkInterface.buildVelos();
thisPipe.elements.push(thisSink);
thisPipe.interfaces.push(sinkInterface);

	   
function drawWorld(){   ///main animation loop
	//console.log("=======================");
	ctx0.fillStyle = "rgba(100,0,100,1)";
	ctx0.fillRect(0,0,width,height);
	for(var j = 0; j < physicsSteps; j++){
		thisPipe.calculateMassFlows(timescale*physicsSteps);

		
	}
	ctx1.clearRect(0,0,width,height);
	
	thisPipe.render(ctx1);
	ctx0.drawImage(canvas1,0,0);

	requestAnimationFrame(drawWorld);
}
console.log("All good!");
drawWorld();





</script>
</body>
